<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-sequitR Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 1rem;
        }

        .container {
            max-width: 1000px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 0.5rem;
            font-size: 2.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, #fff, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 1.5rem;
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .setup-screen, .training-screen {
            text-align: center;
            padding: 2rem;
        }

        .setup-screen h2, .training-screen h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .setup-screen p, .training-screen p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            line-height: 1.6;
        }

        .name-input {
            width: 100%;
            max-width: 400px;
            padding: 1rem;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            margin-bottom: 1rem;
            text-align: center;
        }

        .name-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .name-input:focus {
            outline: none;
            border-color: #ffd700;
        }

        .rhyme-display {
            font-size: 1.5rem;
            font-weight: bold;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            margin: 2rem 0;
            line-height: 2;
            font-style: italic;
        }

        .training-instruction {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: #ffd700;
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(255, 107, 107, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .connection-status {
            text-align: center;
            padding: 0.75rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .connected {
            background: linear-gradient(45deg, rgba(46, 204, 113, 0.3), rgba(52, 152, 219, 0.3));
        }

        .disconnected {
            background: linear-gradient(45deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.3));
        }

        .room-info {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            margin-bottom: 1.5rem;
        }

        .room-code {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
            letter-spacing: 3px;
        }

        .conversation {
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 1.5rem;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.15);
            padding: 1rem;
        }

        .conversation::-webkit-scrollbar {
            width: 8px;
        }

        .conversation::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .conversation::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }

        .message-pair {
            margin-bottom: 1.5rem;
            animation: fadeInUp 0.5s ease;
        }

        .message {
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 0.5rem;
        }

        .original {
            background: rgba(255, 255, 255, 0.12);
            border-left: 4px solid rgba(255, 255, 255, 0.4);
        }

        .translated {
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.25), rgba(254, 202, 87, 0.25));
            border-left: 4px solid #ffd700;
        }

        .translated .changed-word {
            font-weight: bold;
            color: #ffd700;
            text-decoration: underline;
            text-decoration-style: wavy;
        }

        .echo {
            background: linear-gradient(45deg, rgba(155, 89, 182, 0.25), rgba(142, 68, 173, 0.25));
            border-left: 4px solid #9b59b6;
            font-style: italic;
        }

        .callback {
            background: linear-gradient(45deg, rgba(52, 152, 219, 0.25), rgba(41, 128, 185, 0.25));
            border-left: 4px solid #3498db;
            font-style: italic;
        }

        .message-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speaker-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-weight: bold;
        }

        .message-text {
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .settings {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .setting-label {
            font-size: 0.85rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .hidden {
            display: none;
        }

        .participants-online {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .participant-online {
            padding: 0.5rem 1rem;
            background: rgba(46, 204, 113, 0.3);
            border-radius: 20px;
            font-size: 0.9rem;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .listening {
            animation: pulse 2s infinite;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎭 Non-sequitR Pro</h1>
        <p class="subtitle">Multi-Device DDOS • Voice Training • Contextual Humor</p>

        <!-- Setup Screen -->
        <div id="setupScreen" class="setup-screen">
            <h2>Join or Create Room</h2>
            <p>Enter your name and either join an existing room or create a new one!</p>
            
            <input 
                type="text" 
                id="nameInput" 
                class="name-input" 
                placeholder="Your name..."
                maxlength="20"
            />
            <br>
            <input 
                type="text" 
                id="roomCodeInput" 
                class="name-input" 
                placeholder="Room code (leave empty to create new)"
                maxlength="6"
                style="text-transform: uppercase;"
            />
            <br>
            <button id="joinBtn" class="btn btn-primary">🚀 Join / Create Room</button>
            <br><br>
            <p style="font-size: 0.9rem; opacity: 0.7;">
                Note: This version requires a backend server. For local testing, it will simulate multi-user features.
            </p>
        </div>

        <!-- Voice Training Screen -->
        <div id="trainingScreen" class="training-screen hidden">
            <h2>🎤 Voice Training</h2>
            <p>Say this silly rhyme three times so the app can learn your voice!</p>
            
            <div class="rhyme-display" id="rhymeDisplay"></div>
            
            <div class="training-instruction">
                Recordings: <span id="recordingCount">0/3</span>
            </div>
            
            <button id="recordRhymeBtn" class="btn btn-primary">🎙️ Record Rhyme</button>
            <button id="skipTrainingBtn" class="btn btn-secondary">Skip Training</button>
        </div>

        <!-- Main App Screen -->
        <div id="mainScreen" class="hidden">
            <div class="connection-status connected" id="connectionStatus">
                ✓ Connected to Server
            </div>

            <div class="room-info">
                Room Code: <span class="room-code" id="roomCodeDisplay">XXXX</span>
                <br>
                <small>Share this code with others to join!</small>
            </div>

            <div class="participants-online" id="participantsOnline"></div>

            <div class="settings">
                <div class="setting-item">
                    <label class="setting-label">Humor Intensity: <span id="humorValue">60</span>%</label>
                    <input type="range" id="humorSlider" class="slider" min="0" max="100" value="60">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Callback Chance: <span id="callbackValue">40</span>%</label>
                    <input type="range" id="callbackSlider" class="slider" min="0" max="100" value="40">
                </div>
            </div>

            <div style="text-align: center; margin-bottom: 1rem;">
                <button id="startListenBtn" class="btn btn-primary">🎤 Start Listening</button>
                <button id="stopListenBtn" class="btn btn-secondary" disabled>⏹ Stop</button>
            </div>

            <div id="conversation" class="conversation">
                <div class="message-pair">
                    <div class="message original">
                        <div class="message-label">
                            <span class="speaker-badge">Example</span>
                        </div>
                        <div class="message-text">I'm going to the store later</div>
                    </div>
                    <div class="message translated">
                        <div class="message-label">
                            <span class="speaker-badge">Translation</span>
                        </div>
                        <div class="message-text">I'm going to the <span class="changed-word">snore</span> later</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // This is a sophisticated frontend that would connect to a WebSocket backend
        // For demonstration, it simulates the backend locally

        class NonSequitRPro {
            constructor() {
                this.userName = '';
                this.roomCode = '';
                this.isListening = false;
                this.humorIntensity = 60;
                this.callbackChance = 40;
                this.conversationHistory = [];
                this.keyTopics = new Map();
                this.recognition = null;
                this.currentRhyme = '';
                this.recordingCount = 0;
                this.socket = null;
                this.voiceTrainingData = [];
                this.usedRhymes = [];
                this.isRecording = false;
                this.silenceTimeout = null;
                this.serverUrl = 'http://localhost:3000'; // Change to your server URL
                
                this.setupElements();
                this.setupEventListeners();
                this.generateSillyRhyme();
                this.initializeSocket();
            }

            initializeSocket() {
                // Try to connect to server, fall back to local mode if unavailable
                try {
                    // For production, uncomment these lines:
                    // this.socket = io(this.serverUrl);
                    // this.setupSocketListeners();
                    console.log('Running in local demo mode - to enable multi-user, connect to server');
                } catch (e) {
                    console.log('Running in local demo mode');
                }
            }

            setupSocketListeners() {
                if (!this.socket) return;

                this.socket.on('connect', () => {
                    document.getElementById('connectionStatus').textContent = '✓ Connected to Server';
                    document.getElementById('connectionStatus').className = 'connection-status connected';
                });

                this.socket.on('disconnect', () => {
                    document.getElementById('connectionStatus').textContent = '✗ Disconnected';
                    document.getElementById('connectionStatus').className = 'connection-status disconnected';
                });

                this.socket.on('participant-joined', ({ participants, newParticipant }) => {
                    this.updateParticipantsDisplay(participants);
                    if (newParticipant && newParticipant.name !== this.userName) {
                        this.showNotification(`${newParticipant.name} joined the room! 🎉`);
                    }
                });

                this.socket.on('participant-left', ({ userName, participants }) => {
                    this.updateParticipantsDisplay(participants);
                    this.showNotification(`${userName} left the room`);
                });

                this.socket.on('new-message', (message) => {
                    // Only display messages from others
                    if (message.socketId !== this.socket.id) {
                        this.addMessage(message.original, message.translated, message.changedIndices, message.userName);
                        
                        // Store in local history for callbacks
                        this.conversationHistory.push({ 
                            original: message.original, 
                            translated: message.translated,
                            speaker: message.userName 
                        });
                        if (this.conversationHistory.length > 15) {
                            this.conversationHistory.shift();
                        }
                    }
                });

                this.socket.on('callback-message', ({ text, speaker }) => {
                    this.addCallbackMessage(text, speaker);
                });

                this.socket.on('conversation-history', (history) => {
                    // Load existing conversation when joining
                    history.forEach(msg => {
                        this.addMessage(msg.original, msg.translated, msg.changedIndices, msg.userName);
                    });
                    if (history.length > 0) {
                        this.showNotification('Loaded conversation history');
                    }
                });
            }

            updateParticipantsDisplay(participants) {
                const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
                
                this.participantsOnline.innerHTML = participants.map((p, index) => {
                    const color = colors[index % colors.length];
                    const isYou = this.socket ? (p.id === this.socket.id) : (p.name === this.userName);
                    return `
                        <div class="participant-online" style="border-left: 3px solid ${color}">
                            <span style="font-size: 1.5rem;">${this.getAvatarEmoji(index)}</span>
                            ${p.name} ${isYou ? '(You)' : ''}
                        </div>
                    `;
                }).join('');
            }

            getAvatarEmoji(index) {
                const avatars = ['🎭', '🎪', '🎨', '🎬', '🎤', '🎧', '🎸', '🎹', '🎺', '🎻'];
                return avatars[index % avatars.length];
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(45deg, rgba(46, 204, 113, 0.95), rgba(52, 152, 219, 0.95));
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 10px;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    z-index: 9999;
                    animation: slideInRight 0.5s ease;
                    font-weight: bold;
                `;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.5s ease';
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            }

            setupElements() {
                this.setupScreen = document.getElementById('setupScreen');
                this.trainingScreen = document.getElementById('trainingScreen');
                this.mainScreen = document.getElementById('mainScreen');
                this.nameInput = document.getElementById('nameInput');
                this.roomCodeInput = document.getElementById('roomCodeInput');
                this.joinBtn = document.getElementById('joinBtn');
                this.rhymeDisplay = document.getElementById('rhymeDisplay');
                this.recordingCountEl = document.getElementById('recordingCount');
                this.recordRhymeBtn = document.getElementById('recordRhymeBtn');
                this.skipTrainingBtn = document.getElementById('skipTrainingBtn');
                this.roomCodeDisplay = document.getElementById('roomCodeDisplay');
                this.participantsOnline = document.getElementById('participantsOnline');
                this.conversation = document.getElementById('conversation');
                this.startListenBtn = document.getElementById('startListenBtn');
                this.stopListenBtn = document.getElementById('stopListenBtn');
                this.humorSlider = document.getElementById('humorSlider');
                this.humorValue = document.getElementById('humorValue');
                this.callbackSlider = document.getElementById('callbackSlider');
                this.callbackValue = document.getElementById('callbackValue');
            }

            setupEventListeners() {
                this.joinBtn.addEventListener('click', () => this.joinRoom());
                this.recordRhymeBtn.addEventListener('click', () => this.recordRhyme());
                this.skipTrainingBtn.addEventListener('click', () => this.skipTraining());
                this.startListenBtn.addEventListener('click', () => this.startListening());
                this.stopListenBtn.addEventListener('click', () => this.stopListening());
                
                this.humorSlider.addEventListener('input', (e) => {
                    this.humorIntensity = parseInt(e.target.value);
                    this.humorValue.textContent = this.humorIntensity;
                });

                this.callbackSlider.addEventListener('input', (e) => {
                    this.callbackChance = parseInt(e.target.value);
                    this.callbackValue.textContent = this.callbackChance;
                });

                this.nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.joinRoom();
                });
            }

            generateSillyRhyme() {
                const rhymes = [
                    "Peter Piper picked a peck of pickled peppers",
                    "She sells seashells by the seashore",
                    "How much wood would a woodchuck chuck",
                    "Fuzzy Wuzzy was a bear, Fuzzy Wuzzy had no hair",
                    "I scream, you scream, we all scream for ice cream",
                    "Red lorry, yellow lorry, red lorry, yellow lorry",
                    "Unique New York, you need New York, you know you need unique New York",
                    "Irish wristwatch, Swiss wristwatch",
                    "Toy boat, toy boat, toy boat",
                    "Six sleek swans swam swiftly southwards"
                ];
                
                // Pick a random rhyme that hasn't been used yet
                const availableRhymes = rhymes.filter(r => !this.usedRhymes.includes(r));
                if (availableRhymes.length === 0) {
                    this.usedRhymes = []; // Reset if all used
                }
                
                const rhyme = availableRhymes[Math.floor(Math.random() * availableRhymes.length)] || rhymes[0];
                this.usedRhymes.push(rhyme);
                this.currentRhyme = rhyme;
                this.rhymeDisplay.textContent = rhyme;
            }

            joinRoom() {
                this.userName = this.nameInput.value.trim();
                if (!this.userName) {
                    alert('Please enter your name!');
                    return;
                }

                const inputRoomCode = this.roomCodeInput.value.trim().toUpperCase();
                
                if (inputRoomCode) {
                    // User entered a room code - join existing room
                    this.roomCode = inputRoomCode;
                    this.roomCodeDisplay.textContent = this.roomCode;
                    
                    // If socket is available, it will verify the room exists
                    if (this.socket?.connected) {
                        this.socket.emit('check-room', { roomCode: this.roomCode }, (response) => {
                            if (response.exists) {
                                // Room exists, proceed to training
                                this.setupScreen.classList.add('hidden');
                                this.trainingScreen.classList.remove('hidden');
                            } else {
                                alert(`Room ${this.roomCode} not found. Creating new room with this code.`);
                                this.setupScreen.classList.add('hidden');
                                this.trainingScreen.classList.remove('hidden');
                            }
                        });
                    } else {
                        // Local mode - just proceed
                        this.setupScreen.classList.add('hidden');
                        this.trainingScreen.classList.remove('hidden');
                    }
                } else {
                    // No room code entered - create new room
                    this.roomCode = this.generateRoomCode();
                    this.roomCodeDisplay.textContent = this.roomCode;
                    this.setupScreen.classList.add('hidden');
                    this.trainingScreen.classList.remove('hidden');
                }
            }

            generateRoomCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }

            async recordRhyme() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.recordRhymeBtn.disabled = true;
                this.recordRhymeBtn.textContent = '🎙️ Listening... Speak now!';

                // Setup speech recognition for auto-detection
                if (!this.trainingRecognition) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (!SpeechRecognition) {
                        alert('Speech recognition not supported');
                        return;
                    }
                    this.trainingRecognition = new SpeechRecognition();
                    this.trainingRecognition.continuous = true;
                    this.trainingRecognition.interimResults = true;
                }

                let lastSpeechTime = Date.now();
                let spokenText = '';

                this.trainingRecognition.onresult = (event) => {
                    lastSpeechTime = Date.now();
                    
                    // Get the latest result
                    const result = event.results[event.results.length - 1];
                    const transcript = result[0].transcript;
                    
                    if (result.isFinal) {
                        spokenText += transcript + ' ';
                    }
                    
                    // Reset silence timeout
                    if (this.silenceTimeout) {
                        clearTimeout(this.silenceTimeout);
                    }
                    
                    // Check for 2 seconds of silence to auto-stop
                    this.silenceTimeout = setTimeout(() => {
                        if (Date.now() - lastSpeechTime >= 2000 && spokenText.trim().length > 10) {
                            this.stopRecording(spokenText);
                        }
                    }, 2000);
                };

                this.trainingRecognition.onerror = (event) => {
                    console.error('Recognition error:', event.error);
                    if (event.error === 'no-speech') {
                        setTimeout(() => {
                            if (this.isRecording && spokenText.trim().length > 10) {
                                this.stopRecording(spokenText);
                            }
                        }, 1000);
                    }
                };

                try {
                    this.trainingRecognition.start();
                } catch (e) {
                    console.error('Start error:', e);
                    this.isRecording = false;
                    this.recordRhymeBtn.disabled = false;
                    this.recordRhymeBtn.textContent = '🎙️ Record Rhyme';
                }
            }

            stopRecording(spokenText) {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                
                try {
                    if (this.trainingRecognition) {
                        this.trainingRecognition.stop();
                    }
                } catch (e) {
                    console.error('Stop error:', e);
                }
                
                if (this.silenceTimeout) {
                    clearTimeout(this.silenceTimeout);
                }

                // Store voice training data
                this.voiceTrainingData.push({
                    timestamp: Date.now(),
                    text: spokenText.trim(),
                    expectedRhyme: this.currentRhyme
                });

                this.recordingCount++;
                if (this.recordingCountEl) {
                    this.recordingCountEl.textContent = `${this.recordingCount}/3`;
                }

                if (this.recordingCount >= 3) {
                    this.completeTraining();
                } else {
                    // Generate a new rhyme for the next recording
                    this.generateSillyRhyme();
                    this.recordRhymeBtn.disabled = false;
                    this.recordRhymeBtn.textContent = '🎙️ Record Next Rhyme';
                }
            }

            completeTraining() {
                if (this.socket) {
                    // Send voice training to server
                    this.socket.emit('join-room', {
                        userName: this.userName,
                        roomCode: this.roomCode,
                        voiceData: this.voiceTrainingData
                    });
                }
                
                this.trainingScreen.classList.add('hidden');
                this.mainScreen.classList.remove('hidden');
                this.updateParticipants();
                this.setupSpeechRecognition();
            }

            updateParticipants() {
                if (this.socket) return; // Socket will handle this
                
                // Local mode
                this.participantsOnline.innerHTML = `
                    <div class="participant-online">👤 ${this.userName} (You)</div>
                `;
            }

            setupSpeechRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    alert('Speech recognition not supported');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();
                this.recognition.continuous = true;
                this.recognition.interimResults = false;

                this.recognition.onresult = (event) => {
                    const result = event.results[event.results.length - 1];
                    if (result.isFinal) {
                        const transcript = result[0].transcript.trim();
                        if (transcript) {
                            this.processTranscript(transcript);
                        }
                    }
                };
            }

            startListening() {
                if (this.recognition) {
                    this.recognition.start();
                    this.isListening = true;
                    this.startListenBtn.disabled = true;
                    this.stopListenBtn.disabled = false;
                    this.startListenBtn.classList.add('listening');
                }
            }

            stopListening() {
                if (this.recognition) {
                    this.recognition.stop();
                    this.isListening = false;
                    this.startListenBtn.disabled = false;
                    this.stopListenBtn.disabled = true;
                    this.startListenBtn.classList.remove('listening');
                }
            }

            processTranscript(text) {
                const translation = this.createFunnyTranslation(text);
                this.addMessage(text, translation.text, translation.changedIndices, this.userName);
                
                // Broadcast to server if connected
                if (this.socket?.connected) {
                    this.socket.emit('new-transcript', {
                        original: text,
                        translated: translation.text,
                        changedIndices: translation.changedIndices,
                        speakerConfidence: 0.95 // Would come from voice recognition
                    });
                }
                
                // Store in local history
                this.conversationHistory.push({ original: text, translated: translation.text });
                if (this.conversationHistory.length > 15) {
                    this.conversationHistory.shift();
                }

                // Maybe add a callback
                if (Math.random() * 100 < this.callbackChance && this.conversationHistory.length > 2) {
                    setTimeout(() => {
                        if (this.socket?.connected) {
                            this.socket.emit('request-callback');
                        } else {
                            this.addCallback();
                        }
                    }, 2000);
                }
            }

            createFunnyTranslation(text) {
                const words = text.split(' ');
                const threshold = this.humorIntensity / 100;
                let changedIndices = [];
                
                // Strategic word replacement - target key words for maximum impact
                const result = words.map((word, index) => {
                    const cleanWord = word.toLowerCase().replace(/[.,!?;:]$/, '');
                    const punctuation = word.match(/[.,!?;:]$/)?.[0] || '';
                    
                    // Higher chance to change nouns, verbs, and important words
                    const isKeyWord = this.isImportantWord(cleanWord);
                    const changeChance = isKeyWord ? threshold * 1.5 : threshold * 0.5;
                    
                    if (Math.random() < changeChance) {
                        const replacement = this.getFunnyReplacement(cleanWord);
                        if (replacement && replacement !== cleanWord) {
                            changedIndices.push(index);
                            // Track this topic for callbacks
                            this.keyTopics.set(cleanWord, replacement);
                            return replacement + punctuation;
                        }
                    }
                    
                    return word;
                });

                return {
                    text: result.join(' '),
                    changedIndices: changedIndices
                };
            }

            isImportantWord(word) {
                // Check if word is likely a noun or verb (simplified)
                const commonWords = ['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as', 'but', 'or', 'and', 'if', 'then'];
                return !commonWords.includes(word) && word.length > 3;
            }

            getFunnyReplacement(word) {
                const mishearings = {
                    'meeting': 'eating', 'later': 'gator', 'store': 'snore',
                    'coffee': 'toffee', 'work': 'quirk', 'think': 'stink',
                    'going': 'gong', 'dinner': 'winner', 'lunch': 'bunch',
                    'phone': 'bone', 'email': 'snail', 'problem': 'goblin',
                    'important': 'imported', 'difficult': 'delicious',
                    'understand': 'underhand', 'explain': 'complain',
                    'money': 'honey', 'ready': 'freddy', 'busy': 'dizzy',
                    'happy': 'snappy', 'tired': 'wired', 'great': 'grate',
                    'nice': 'mice', 'friend': 'fiend', 'talking': 'walking'
                };

                return mishearings[word] || word;
            }

            addCallback() {
                if (this.keyTopics.size === 0 && this.conversationHistory.length === 0) return;

                // Pick a random earlier topic or speaker
                let callbackText;
                
                if (this.keyTopics.size > 0 && Math.random() < 0.6) {
                    // Reference a misheard word
                    const topics = Array.from(this.keyTopics.entries());
                    const [original, replacement] = topics[Math.floor(Math.random() * topics.length)];

                    const callbacks = [
                        `Wait, did someone say ${replacement}?`,
                        `Going back to that ${replacement} thing...`,
                        `I'm still thinking about ${replacement}!`,
                        `${replacement}? ${replacement}!`,
                        `Remember when we were talking about ${replacement}?`,
                        `Hold on, ${replacement}? Really?`,
                        `Can we circle back to ${replacement}?`
                    ];
                    callbackText = callbacks[Math.floor(Math.random() * callbacks.length)];
                } else if (this.conversationHistory.length > 0) {
                    // Riff on an earlier speaker's message
                    const oldMessage = this.conversationHistory[Math.floor(Math.random() * this.conversationHistory.length)];
                    const riffs = [
                        `Like ${oldMessage.speaker || 'someone'} said earlier...`,
                        `That reminds me of what ${oldMessage.speaker || 'someone'} mentioned`,
                        `${oldMessage.speaker || 'Someone'} had a point about that`,
                        `Wait, wasn't ${oldMessage.speaker || 'someone'} talking about this?`
                    ];
                    callbackText = riffs[Math.floor(Math.random() * riffs.length)];
                }

                if (callbackText) {
                    this.addCallbackMessage(callbackText, this.userName);
                }
            }

            addMessage(original, translated, changedIndices, speakerName = this.userName) {
                const words = translated.split(' ');
                const highlightedText = words.map((word, i) => {
                    if (changedIndices.includes(i)) {
                        return `<span class="changed-word">${word}</span>`;
                    }
                    return word;
                }).join(' ');

                const messageHTML = `
                    <div class="message-pair">
                        <div class="message original">
                            <div class="message-label">
                                <span class="speaker-badge">${this.escapeHtml(speakerName)}</span>
                            </div>
                            <div class="message-text">${this.escapeHtml(original)}</div>
                        </div>
                        <div class="message translated">
                            <div class="message-label">
                                <span class="speaker-badge">Translation</span>
                            </div>
                            <div class="message-text">${highlightedText}</div>
                        </div>
                    </div>
                `;

                this.conversation.insertAdjacentHTML('beforeend', messageHTML);
                this.conversation.scrollTop = this.conversation.scrollHeight;
            }

            addCallbackMessage(text, speakerName = 'Echo Bot') {
                const messageHTML = `
                    <div class="message-pair">
                        <div class="message callback">
                            <div class="message-label">
                                <span class="speaker-badge">🔄 ${this.escapeHtml(speakerName)}</span>
                                Callback
                            </div>
                            <div class="message-text">${this.escapeHtml(text)}</div>
                        </div>
                    </div>
                `;

                this.conversation.insertAdjacentHTML('beforeend', messageHTML);
                this.conversation.scrollTop = this.conversation.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new NonSequitRPro();
        });
    </script>
</body>
</html>
